#!/usr/bin/env bash
# wsl-audit — WSL/Docker platform health monitoring tool
# Part of rtgf-ai-stack platform bridge layer
#
# Usage:
#   wsl-audit status     — WSL overview (distros, memory, .wslconfig)
#   wsl-audit docker     — Container health (states, restart loops, policies)
#   wsl-audit processes  — Windows-side WSL/Docker process audit
#   wsl-audit compose    — Compose file linter (risky patterns)
#   wsl-audit risks      — Proactive risk detection summary
#   wsl-audit all        — Run all checks
#   wsl-audit watch [N]  — Re-run all checks every N seconds (default: 30)
#
# Design principles:
#   - No external deps beyond bash + docker CLI (no jq, no python)
#   - Windows-side access via powershell.exe from WSL
#   - Graceful degradation when docker/powershell unavailable
#   - ANSI color with auto-detection for non-TTY

set -uo pipefail

# ─── Color & Output ───────────────────────────────────────────────────────────

if [[ -t 1 ]]; then
    RED='\033[0;31m'
    YELLOW='\033[0;33m'
    GREEN='\033[0;32m'
    CYAN='\033[0;36m'
    BOLD='\033[1m'
    DIM='\033[2m'
    RESET='\033[0m'
else
    RED='' YELLOW='' GREEN='' CYAN='' BOLD='' DIM='' RESET=''
fi

CRIT_COUNT=0
WARN_COUNT=0

DOCKER_AVAILABLE=false
POWERSHELL_AVAILABLE=false

crit() { echo -e "${RED}${BOLD}[CRIT]${RESET} $*"; CRIT_COUNT=$((CRIT_COUNT + 1)); }
warn() { echo -e "${YELLOW}[WARN]${RESET} $*"; WARN_COUNT=$((WARN_COUNT + 1)); }
ok()   { echo -e "${GREEN}[ OK ]${RESET} $*"; }
info() { echo -e "${CYAN}[INFO]${RESET} $*"; }
dim()  { echo -e "${DIM}$*${RESET}"; }

section() {
    echo ""
    echo -e "${BOLD}${CYAN}━━━ $* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
}

header() {
    echo ""
    echo -e "${BOLD}╔══════════════════════════════════════════════════════╗${RESET}"
    echo -e "${BOLD}║  wsl-audit — Platform Health Monitor                 ║${RESET}"
    printf   "${BOLD}║  %-52s ║${RESET}\n" "$(date '+%Y-%m-%d %H:%M:%S')"
    echo -e "${BOLD}╚══════════════════════════════════════════════════════╝${RESET}"
}

summary() {
    echo ""
    echo -e "${BOLD}━━━ Summary ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
    if [[ $CRIT_COUNT -gt 0 ]]; then
        echo -e "  ${RED}${BOLD}$CRIT_COUNT critical issue(s) require immediate attention${RESET}"
    fi
    if [[ $WARN_COUNT -gt 0 ]]; then
        echo -e "  ${YELLOW}$WARN_COUNT warning(s) should be reviewed${RESET}"
    fi
    if [[ $CRIT_COUNT -eq 0 && $WARN_COUNT -eq 0 ]]; then
        echo -e "  ${GREEN}${BOLD}All checks passed — platform looks healthy${RESET}"
    fi
    echo ""
}

# ─── Helpers ──────────────────────────────────────────────────────────────────

check_deps() {
    if command -v docker &>/dev/null && docker info &>/dev/null 2>&1; then
        DOCKER_AVAILABLE=true
    fi
    if command -v powershell.exe &>/dev/null; then
        POWERSHELL_AVAILABLE=true
    fi
}

ps_exec() {
    # Run a PowerShell one-liner from WSL, strip UTF-16 null bytes and CR
    powershell.exe -NoProfile -NonInteractive -Command "$1" 2>/dev/null \
        | tr -d '\r\0'
}

find_wslconfig() {
    # Return the first .wslconfig found in any Windows user home
    local f
    for f in /mnt/c/Users/*/.wslconfig; do
        if [[ -f "$f" ]]; then
            echo "$f"
            return 0
        fi
    done
    return 1
}

# ─── Subcommand: status ───────────────────────────────────────────────────────

cmd_status() {
    section "WSL Status"

    local distro="${WSL_DISTRO_NAME:-unknown}"
    local kernel
    kernel=$(uname -r 2>/dev/null || echo "unknown")
    info "Current distro: ${BOLD}$distro${RESET}"
    info "Kernel: $kernel"

    # .wslconfig check
    local wslconfig
    if wslconfig=$(find_wslconfig); then
        ok ".wslconfig found: $wslconfig"

        local mem_cap
        mem_cap=$(grep -iE '^\s*memory\s*=' "$wslconfig" 2>/dev/null | head -1 | tr -d ' ')
        if [[ -n "$mem_cap" ]]; then
            ok ".wslconfig memory cap: ${BOLD}$mem_cap${RESET}"
        else
            crit ".wslconfig exists but no memory= cap — WSL can consume all host RAM"
        fi

        local proc_cap
        proc_cap=$(grep -iE '^\s*processors\s*=' "$wslconfig" 2>/dev/null | head -1 | tr -d ' ')
        if [[ -n "$proc_cap" ]]; then
            ok ".wslconfig processors cap: ${BOLD}$proc_cap${RESET}"
        else
            warn ".wslconfig has no processors= cap (optional but recommended)"
        fi

        local swap_cap
        swap_cap=$(grep -iE '^\s*swap\s*=' "$wslconfig" 2>/dev/null | head -1 | tr -d ' ')
        if [[ -n "$swap_cap" ]]; then
            ok ".wslconfig swap cap: ${BOLD}$swap_cap${RESET}"
        fi
    else
        crit "No .wslconfig found in /mnt/c/Users/*/. No memory cap — WSL can consume all host RAM"
        info "  Fix: Create C:\\Users\\<you>\\.wslconfig with [wsl2] then memory=8GB"
    fi

    # Memory usage
    section "Memory Usage"
    local mem_total mem_available mem_pct
    mem_total=$(grep MemTotal /proc/meminfo | awk '{print $2}')
    mem_available=$(grep MemAvailable /proc/meminfo | awk '{print $2}')
    mem_pct=$(( (mem_total - mem_available) * 100 / mem_total ))
    local mem_total_gb=$(( mem_total / 1024 / 1024 ))
    local mem_used_gb=$(( (mem_total - mem_available) / 1024 / 1024 ))

    if [[ $mem_pct -ge 90 ]]; then
        crit "Memory: ${mem_used_gb}GB / ${mem_total_gb}GB (${mem_pct}%) — CRITICAL"
    elif [[ $mem_pct -ge 80 ]]; then
        warn "Memory: ${mem_used_gb}GB / ${mem_total_gb}GB (${mem_pct}%) — high"
    else
        ok "Memory: ${mem_used_gb}GB / ${mem_total_gb}GB (${mem_pct}%)"
    fi

    # Swap
    local swap_total swap_free
    swap_total=$(grep SwapTotal /proc/meminfo | awk '{print $2}')
    swap_free=$(grep SwapFree /proc/meminfo | awk '{print $2}')
    if [[ $swap_total -gt 0 ]]; then
        local swap_pct=$(( (swap_total - swap_free) * 100 / swap_total ))
        local swap_total_gb=$(( swap_total / 1024 / 1024 ))
        local swap_used_gb=$(( (swap_total - swap_free) / 1024 / 1024 ))
        if [[ $swap_pct -ge 80 ]]; then
            warn "Swap: ${swap_used_gb}GB / ${swap_total_gb}GB (${swap_pct}%) — high"
        else
            ok "Swap: ${swap_used_gb}GB / ${swap_total_gb}GB (${swap_pct}%)"
        fi
    else
        info "Swap: not configured"
    fi

    # Disk usage
    section "Disk Usage"
    local disk_used disk_avail disk_pct
    disk_used=$(df -h / | tail -1 | awk '{print $3}')
    disk_avail=$(df -h / | tail -1 | awk '{print $4}')
    disk_pct=$(df / | tail -1 | awk '{print $5}' | tr -d '%')

    if [[ $disk_pct -ge 90 ]]; then
        crit "Root disk: ${disk_used} used, ${disk_avail} free (${disk_pct}%) — near full"
    elif [[ $disk_pct -ge 80 ]]; then
        warn "Root disk: ${disk_used} used, ${disk_avail} free (${disk_pct}%) — getting full"
    else
        ok "Root disk: ${disk_used} used, ${disk_avail} free (${disk_pct}%)"
    fi

    # Running WSL distros via powershell
    if $POWERSHELL_AVAILABLE; then
        section "WSL Distros (Windows-side)"
        local distro_list
        distro_list=$(ps_exec 'wsl --list --running 2>$null' | grep -v '^\s*$' || true)
        if [[ -n "$distro_list" ]]; then
            info "Running WSL distros:"
            echo "$distro_list" | while IFS= read -r line; do
                dim "  $line"
            done
        else
            info "No additional running distros detected"
        fi
    fi
}

# ─── Subcommand: docker ───────────────────────────────────────────────────────

cmd_docker() {
    section "Docker Container Health"

    if ! $DOCKER_AVAILABLE; then
        info "Docker not available or not running — skipping docker checks"
        return
    fi

    local total running stopped restarting
    total=$(docker ps -aq 2>/dev/null | wc -l)
    running=$(docker ps -q --filter status=running 2>/dev/null | wc -l)
    stopped=$(docker ps -q --filter status=exited 2>/dev/null | wc -l)
    restarting=$(docker ps -q --filter status=restarting 2>/dev/null | wc -l)

    info "Containers: ${BOLD}$total total${RESET}, $running running, $stopped exited, $restarting restarting"

    if [[ $restarting -gt 0 ]]; then
        crit "$restarting container(s) actively restarting — possible restart storm"
    fi

    if [[ $total -eq 0 ]]; then
        ok "No containers present"
        return
    fi

    # Per-container detail
    section "Container Detail"
    local fmt='{{.Names}}\t{{.Status}}\t{{.RestartCount}}\t{{.HostConfig.RestartPolicy.Name}}'
    local name status restart_count policy

    while IFS=$'\t' read -r name status restart_count policy; do
        if [[ "$restart_count" =~ ^[0-9]+$ ]] && [[ $restart_count -ge 10 ]]; then
            crit "Container ${BOLD}$name${RESET}: restartCount=$restart_count — STORM RISK"
        elif [[ "$restart_count" =~ ^[0-9]+$ ]] && [[ $restart_count -ge 3 ]]; then
            warn "Container ${BOLD}$name${RESET}: restartCount=$restart_count, policy=$policy, status=$status"
        elif [[ "$policy" == "always" ]]; then
            warn "Container ${BOLD}$name${RESET}: restart=always (no circuit breaker), status=$status, restarts=$restart_count"
        elif [[ "$policy" == "unless-stopped" ]]; then
            warn "Container ${BOLD}$name${RESET}: restart=unless-stopped (aggressive), status=$status, restarts=$restart_count"
        elif echo "$status" | grep -qi "exited" && ! echo "$status" | grep -qi "exited (0)"; then
            warn "Container ${BOLD}$name${RESET}: $status, restarts=$restart_count"
        else
            ok "Container ${BOLD}$name${RESET}: $status, policy=$policy, restarts=$restart_count"
        fi
    done < <(docker ps -a --format "$fmt" 2>/dev/null)

    # Docker system resource usage
    section "Docker Resource Usage"
    docker system df 2>/dev/null | while IFS= read -r line; do
        dim "  $line"
    done || true
}

# ─── Subcommand: processes ────────────────────────────────────────────────────

cmd_processes() {
    section "WSL/Docker Process Audit"

    if ! $POWERSHELL_AVAILABLE; then
        warn "powershell.exe not available — skipping Windows-side process audit"
        info "  (This check only works when run from inside WSL)"
    else
        section "Top WSL/Docker Processes (Windows-side)"
        local wsl_procs
        wsl_procs=$(ps_exec \
            'Get-Process | Where-Object { $_.ProcessName -match "wsl|docker|vmmem" } | Sort-Object CPU -Descending | Select-Object -First 15 | Format-Table ProcessName, Id, @{N="CPU(s)";E={[math]::Round($_.CPU,1)}}, @{N="RAM(MB)";E={[math]::Round($_.WorkingSet/1MB,0)}} -AutoSize | Out-String' \
            || true)
        if [[ -n "$wsl_procs" ]]; then
            echo "$wsl_procs" | while IFS= read -r line; do
                dim "  $line"
            done
        else
            info "No WSL/Docker processes found on Windows side"
        fi

        section "vmmem Memory Usage"
        local vmmem_info
        vmmem_info=$(ps_exec \
            '$v = Get-Process vmmem -ErrorAction SilentlyContinue; if ($v) { $gb = [math]::Round($v.WorkingSet/1GB,2); $mb = [math]::Round($v.WorkingSet/1MB,0); Write-Output "vmmem PID=$($v.Id) WorkingSet=${gb}GB (${mb}MB)" } else { Write-Output "vmmem not running" }' \
            || echo "vmmem check failed")

        if echo "$vmmem_info" | grep -q "not running"; then
            info "$vmmem_info"
        else
            local vmmem_gb
            vmmem_gb=$(echo "$vmmem_info" | grep -oE '[0-9]+\.[0-9]+GB' | head -1 | tr -d 'GB' || echo "0")
            local vmmem_int=${vmmem_gb%.*}
            if [[ "${vmmem_int:-0}" -ge 12 ]]; then
                crit "$vmmem_info — very large vmmem, check for runaway containers"
            elif [[ "${vmmem_int:-0}" -ge 8 ]]; then
                warn "$vmmem_info — large vmmem"
            else
                ok "$vmmem_info"
            fi
        fi
    fi

    # WSL-side process summary
    section "WSL-side Process Summary"
    local total_procs user_procs
    total_procs=$(ps -e --no-headers 2>/dev/null | wc -l)
    user_procs=$(ps -u "$(id -u)" --no-headers 2>/dev/null | wc -l)
    info "Total processes: $total_procs  (${user_procs} owned by current user)"

    # Flag unusually high process counts (runaway process spawning)
    if [[ $total_procs -ge 500 ]]; then
        warn "Process count ${total_procs} is high — possible runaway process spawning"
        info "  Top process spawners:"
        ps -eo comm --no-headers 2>/dev/null | sort | uniq -c | sort -rn | head -5 \
            | while IFS= read -r line; do dim "    $line"; done
    elif [[ $total_procs -ge 300 ]]; then
        warn "Process count ${total_procs} is elevated"
    else
        ok "Process count: $total_procs"
    fi
}

# ─── Subcommand: compose ─────────────────────────────────────────────────────

cmd_compose() {
    local target="${1:-}"

    section "Docker Compose Linter"

    # Find compose files to lint
    local compose_files=()
    if [[ -n "$target" ]] && [[ -d "$target" ]]; then
        while IFS= read -r f; do
            compose_files+=("$f")
        done < <(find "$target" -maxdepth 3 \
            \( -name "docker-compose*.yml" -o -name "docker-compose*.yaml" \
               -o -name "compose.yml" -o -name "compose.yaml" \) \
            2>/dev/null | sort)
    elif [[ -n "$target" ]] && [[ -f "$target" ]]; then
        compose_files=("$target")
    else
        # Search common locations
        while IFS= read -r f; do
            compose_files+=("$f")
        done < <(find "$HOME" /opt 2>/dev/null -maxdepth 4 \
            \( -name "docker-compose*.yml" -o -name "docker-compose*.yaml" \
               -o -name "compose.yml" -o -name "compose.yaml" \) \
            2>/dev/null | sort)
    fi

    if [[ ${#compose_files[@]} -eq 0 ]]; then
        info "No compose files found (pass a path: wsl-audit compose /path/to/dir)"
        return
    fi

    info "Checking ${#compose_files[@]} compose file(s)..."

    local cf
    for cf in "${compose_files[@]}"; do
        echo ""
        info "File: ${BOLD}$cf${RESET}"
        local file_issues=0

        # restart: always — no circuit breaker
        if grep -qE '^\s+restart:\s+always' "$cf" 2>/dev/null; then
            warn "  restart: always (no circuit breaker, no backoff)"
            warn "  Fix: Use 'restart: on-failure:5' or add deploy.restart_policy.max_attempts"
            file_issues=$((file_issues + 1))
        fi

        # restart: unless-stopped
        if grep -qE '^\s+restart:\s+unless-stopped' "$cf" 2>/dev/null; then
            warn "  restart: unless-stopped (aggressive — persists across Docker restarts)"
            file_issues=$((file_issues + 1))
        fi

        # privileged containers
        if grep -qE '^\s+privileged:\s+true' "$cf" 2>/dev/null; then
            warn "  privileged: true — container has full host access"
            file_issues=$((file_issues + 1))
        fi

        # host network mode
        if grep -qE 'network_mode:\s*host' "$cf" 2>/dev/null; then
            warn "  network_mode: host — container shares host network stack"
            file_issues=$((file_issues + 1))
        fi

        # Missing memory limits
        if ! grep -qE '(mem_limit|memory:)' "$cf" 2>/dev/null; then
            warn "  No memory limits configured (containers can consume all WSL RAM)"
            file_issues=$((file_issues + 1))
        fi

        # Sensitive volume mounts — using double quotes to avoid quoting issues
        local sensitive_mounts
        sensitive_mounts=$(grep -oE "[\"']?/etc:[^\"' ]*|[\"']?/root:[^\"' ]*|[\"']?/proc:[^\"' ]*|[\"']?/sys:[^\"' ]*" "$cf" 2>/dev/null | head -5 || true)
        if [[ -n "$sensitive_mounts" ]]; then
            warn "  Sensitive volume mounts found:"
            echo "$sensitive_mounts" | while IFS= read -r m; do
                dim "    $m"
            done
            file_issues=$((file_issues + 1))
        fi

        # Unresolved environment variable references
        local env_file
        env_file="$(dirname "$cf")/.env"
        local unset_count=0
        while IFS= read -r varname; do
            if [[ -n "$varname" ]]; then
                if [[ -z "${!varname:-}" ]]; then
                    if [[ ! -f "$env_file" ]] || ! grep -q "^${varname}=" "$env_file" 2>/dev/null; then
                        unset_count=$((unset_count + 1))
                    fi
                fi
            fi
        done < <(grep -oE '\$\{?[A-Z_][A-Z0-9_]*\}?' "$cf" 2>/dev/null \
                 | grep -oE '[A-Z_][A-Z0-9_]+' | sort -u | head -20)

        if [[ $unset_count -gt 0 ]]; then
            warn "  $unset_count environment variable(s) may not be set (check .env file)"
            file_issues=$((file_issues + 1))
        fi

        if [[ $file_issues -eq 0 ]]; then
            ok "  No issues found"
        fi
    done
}

# ─── Subcommand: risks ────────────────────────────────────────────────────────

cmd_risks() {
    section "Proactive Risk Detection"

    # 1. Docker Desktop Windows auto-start
    if $POWERSHELL_AVAILABLE; then
        local dd_autostart
        dd_autostart=$(ps_exec \
            '$r = "HKCU:\Software\Microsoft\Windows\CurrentVersion\Run"; $v = Get-ItemProperty $r -Name "Docker Desktop" -ErrorAction SilentlyContinue; if ($v) { Write-Output "enabled" } else { Write-Output "not-set" }' \
            || echo "check-failed")
        if [[ "$dd_autostart" == "enabled" ]]; then
            warn "Docker Desktop in Windows startup — launches on every boot"
            warn "  Early-boot restart storms risk if containers were left running"
        elif [[ "$dd_autostart" == "not-set" ]]; then
            ok "Docker Desktop: not in Windows startup"
        else
            info "Docker Desktop auto-start: could not check (PowerShell required)"
        fi
    fi

    # 2. .wslconfig memory cap
    if find_wslconfig >/dev/null 2>&1; then
        local wslconfig
        wslconfig=$(find_wslconfig)
        if grep -qiE '^\s*memory\s*=' "$wslconfig" 2>/dev/null; then
            local cap
            cap=$(grep -iE '^\s*memory\s*=' "$wslconfig" | head -1 | tr -d ' ')
            ok ".wslconfig memory cap: $cap"
        else
            crit ".wslconfig exists but no memory= cap — restart storm can consume all host RAM"
        fi
    else
        crit "No .wslconfig memory cap — restart storm can consume all host RAM"
        info "  Fix: Add [wsl2] then memory=8GB to C:\\Users\\<you>\\.wslconfig"
    fi

    # 3. Containers currently restarting
    if $DOCKER_AVAILABLE; then
        local restarting_names
        restarting_names=$(docker ps --filter status=restarting --format '{{.Names}}' 2>/dev/null | tr '\n' ' ')
        if [[ -n "$restarting_names" ]]; then
            crit "Containers currently in restart loop: $restarting_names"
        else
            ok "No containers currently in restart state"
        fi

        # High restart count containers
        local high_restart_info=""
        while IFS=$'\t' read -r cname ccount; do
            if [[ "$ccount" =~ ^[0-9]+$ ]] && [[ $ccount -ge 5 ]]; then
                high_restart_info="$high_restart_info $cname(${ccount}x)"
            fi
        done < <(docker ps -a --format '{{.Names}}\t{{.RestartCount}}' 2>/dev/null)

        if [[ -n "$high_restart_info" ]]; then
            warn "Containers with high restart counts:$high_restart_info"
        else
            ok "No containers with high restart counts"
        fi

        # Stale exited containers
        local stale_count
        stale_count=$(docker ps -q --filter status=exited 2>/dev/null | wc -l)
        if [[ $stale_count -ge 20 ]]; then
            warn "$stale_count exited containers accumulated — run: docker container prune"
        elif [[ $stale_count -ge 5 ]]; then
            info "$stale_count exited containers (run: docker container prune when convenient)"
        else
            ok "Exited containers: $stale_count (clean)"
        fi

        # Dangling images
        local dangling
        dangling=$(docker images -f dangling=true -q 2>/dev/null | wc -l)
        if [[ $dangling -ge 10 ]]; then
            warn "$dangling dangling images — run: docker image prune"
        else
            ok "Dangling images: $dangling"
        fi

        # Docker root disk usage
        local docker_root
        docker_root=$(docker info --format '{{.DockerRootDir}}' 2>/dev/null || echo "")
        if [[ -n "$docker_root" ]] && [[ -d "$docker_root" ]]; then
            local dp
            dp=$(df "$docker_root" 2>/dev/null | tail -1 | awk '{print $5}' | tr -d '%')
            if [[ -n "$dp" ]]; then
                if [[ $dp -ge 90 ]]; then
                    crit "Docker root disk ($docker_root): ${dp}% full"
                elif [[ $dp -ge 80 ]]; then
                    warn "Docker root disk ($docker_root): ${dp}% full"
                else
                    ok "Docker root disk ($docker_root): ${dp}% used"
                fi
            fi
        fi
    else
        info "Docker not available — skipping container risk checks"
    fi

    # 4. Current WSL memory pressure
    local mem_total mem_available mem_pct
    mem_total=$(grep MemTotal /proc/meminfo | awk '{print $2}')
    mem_available=$(grep MemAvailable /proc/meminfo | awk '{print $2}')
    mem_pct=$(( (mem_total - mem_available) * 100 / mem_total ))
    if [[ $mem_pct -ge 90 ]]; then
        crit "Current WSL memory pressure: ${mem_pct}% — immediate risk"
    elif [[ $mem_pct -ge 80 ]]; then
        warn "Current WSL memory pressure: ${mem_pct}%"
    else
        ok "Current WSL memory pressure: ${mem_pct}%"
    fi
}

# ─── Subcommand: all ─────────────────────────────────────────────────────────

cmd_all() {
    header
    check_deps

    cmd_status
    cmd_docker
    cmd_processes
    cmd_compose "${1:-}"
    cmd_risks

    summary
}

# ─── Subcommand: watch ────────────────────────────────────────────────────────

cmd_watch() {
    local interval="${1:-30}"
    if ! [[ "$interval" =~ ^[0-9]+$ ]]; then
        echo "Usage: wsl-audit watch [seconds]" >&2
        exit 1
    fi
    echo "Watching — refreshing every ${interval}s (Ctrl+C to stop)"
    while true; do
        CRIT_COUNT=0
        WARN_COUNT=0
        if [[ -t 1 ]]; then
            clear
        fi
        cmd_all
        echo ""
        echo -e "${DIM}Next refresh in ${interval}s — Ctrl+C to stop${RESET}"
        sleep "$interval"
    done
}

# ─── Subcommand: help ─────────────────────────────────────────────────────────

cmd_help() {
    cat <<'HELPEOF'
wsl-audit — WSL/Docker platform health monitoring tool

USAGE:
    wsl-audit <command> [args]

COMMANDS:
    status               WSL overview: distros, memory, .wslconfig caps
    docker               Container health: states, restart counts, policies
    processes            Windows-side process audit (requires powershell.exe)
    compose [path]       Docker Compose linter: risky patterns, missing limits
                         Optional: path to directory or compose file to lint
    risks                Proactive risk detection (auto-start, missing caps, storms)
    all [path]           Run all checks (pass compose path for linter)
    watch [N]            Re-run all checks every N seconds (default: 30)

SEVERITY LEVELS:
    [CRIT]  Requires immediate attention — platform safety risk
    [WARN]  Should be reviewed — potential issue
    [ OK ]  Check passed
    [INFO]  Informational

CRITICAL PATTERNS DETECTED:
    - Docker containers with restart: always (no circuit breaker)
    - RestartCount >= 3 (restart loop risk), >= 10 (storm in progress)
    - Missing .wslconfig memory cap
    - Memory usage >= 80% or disk usage >= 80%
    - Docker Desktop in Windows auto-start
    - Currently restarting containers

EXAMPLES:
    wsl-audit all                          Run full check
    wsl-audit compose ~/LibreChat/         Lint LibreChat compose files
    wsl-audit watch 60                     Monitor, refresh every 60s
    wsl-audit docker                       Quick container health check
    wsl-audit risks                        Proactive risk summary only

GOVERNANCE (INTenX WSL instances):
    - .wslconfig with memory= cap is REQUIRED before running AI services
    - No restart: always without deploy.restart_policy.max_attempts limit
    - Run 'wsl-audit compose' before starting any new Docker service

HELPEOF
}

# ─── Main dispatch ────────────────────────────────────────────────────────────

main() {
    local cmd="${1:-help}"
    shift || true

    if [[ "$cmd" != "all" && "$cmd" != "watch" ]]; then
        check_deps
    fi

    case "$cmd" in
        status)    cmd_status ;;
        docker)    cmd_docker ;;
        processes) cmd_processes ;;
        compose)   cmd_compose "${1:-}" ;;
        risks)     cmd_risks ;;
        all)       cmd_all "${1:-}" ;;
        watch)     cmd_watch "${1:-30}" ;;
        help|--help|-h) cmd_help ;;
        *)
            echo "Unknown command: $cmd" >&2
            echo "Run 'wsl-audit help' for usage" >&2
            exit 1
            ;;
    esac

    if [[ "$cmd" =~ ^(status|docker|processes|compose|risks)$ ]]; then
        summary
    fi
}

main "$@"

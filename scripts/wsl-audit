#!/usr/bin/env bash
# wsl-audit â€” WSL/Docker platform health monitoring tool
# Part of rtgf-ai-stack platform bridge layer
#
# Usage:
#   wsl-audit status     â€” WSL overview (distros, memory, .wslconfig)
#   wsl-audit docker     â€” Container health (states, restart loops, policies)
#   wsl-audit processes  â€” Windows-side WSL/Docker process audit
#   wsl-audit compose    â€” Compose file linter (risky patterns)
#   wsl-audit risks      â€” Proactive risk detection summary
#   wsl-audit all        â€” Run all checks
#   wsl-audit watch [N]  â€” Re-run all checks every N seconds (default: 30)
#
# Design principles:
#   - No external deps beyond bash + docker CLI (no jq, no python)
#   - Windows-side access via powershell.exe from WSL
#   - Graceful degradation when docker/powershell unavailable
#   - ANSI color with auto-detection for non-TTY

set -uo pipefail

# â”€â”€â”€ Color & Output â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

if [[ -t 1 ]]; then
    RED='\033[0;31m'
    YELLOW='\033[0;33m'
    GREEN='\033[0;32m'
    CYAN='\033[0;36m'
    BOLD='\033[1m'
    DIM='\033[2m'
    RESET='\033[0m'
else
    RED='' YELLOW='' GREEN='' CYAN='' BOLD='' DIM='' RESET=''
fi

CRIT_COUNT=0
WARN_COUNT=0

DOCKER_AVAILABLE=false
POWERSHELL_AVAILABLE=false

# â”€â”€â”€ Structured Event Log â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Phase 2: Emit structured JSONL events alongside human-readable output.
# Log dir: ~/.local/share/wsl-audit/events/YYYY-MM-DD.jsonl
# No external deps (no jq/python) â€” JSON built with printf + sed escaping.

EVENT_LOG_DIR="${HOME}/.local/share/wsl-audit/events"
EVENT_LOG_FILE="${EVENT_LOG_DIR}/$(date -u '+%Y-%m-%d').jsonl"
CURRENT_SECTION=""

# Telegram alerting for CRIT events (optional â€” gracefully degrades if unset)
# Set these in ~/.local/share/wsl-audit/alert.env:
#   TELEGRAM_TOKEN=...
#   TELEGRAM_CHAT_ID=...
TELEGRAM_TOKEN="${TELEGRAM_TOKEN:-}"
TELEGRAM_CHAT_ID="${TELEGRAM_CHAT_ID:-}"
ALERT_ENV_FILE="${HOME}/.local/share/wsl-audit/alert.env"
if [[ -f "$ALERT_ENV_FILE" ]]; then
    # shellcheck source=/dev/null
    source "$ALERT_ENV_FILE" 2>/dev/null || true
fi

# Cooldown: suppress repeated CRIT Telegram alerts for same message (1h window)
ALERT_COOLDOWN_DIR="${HOME}/.local/share/wsl-audit/.cooldown"

_json_escape() {
    # Escape string for safe inclusion as a JSON string value (no external deps)
    printf '%s' "$1" | tr '\n\r\t' '   ' | sed 's/\\/\\\\/g; s/"/\\"/g'
}

_emit_event() {
    local severity="$1"
    local section="$2"
    local message="$3"
    local ts
    ts="$(date -u '+%Y-%m-%dT%H:%M:%SZ')"
    local esc_msg esc_sec esc_host esc_distro
    esc_msg="$(_json_escape "$message")"
    esc_sec="$(_json_escape "$section")"
    esc_host="$(_json_escape "$(hostname 2>/dev/null || echo 'unknown')")"
    esc_distro="$(_json_escape "${WSL_DISTRO_NAME:-unknown}")"

    mkdir -p "$EVENT_LOG_DIR" 2>/dev/null || true
    printf '{"ts":"%s","severity":"%s","section":"%s","message":"%s","host":"%s","distro":"%s"}\n' \
        "$ts" "$severity" "$esc_sec" "$esc_msg" "$esc_host" "$esc_distro" \
        >> "$EVENT_LOG_FILE" 2>/dev/null || true
}

_send_telegram_alert() {
    local message="$1"
    [[ -z "${TELEGRAM_TOKEN}" || -z "${TELEGRAM_CHAT_ID}" ]] && return 0
    ! command -v curl &>/dev/null && return 0

    # Cooldown check: don't re-alert same message within 1 hour
    local cooldown_key
    cooldown_key="$(printf '%s' "$message" | tr -dc 'a-zA-Z0-9' | head -c 32)"
    mkdir -p "$ALERT_COOLDOWN_DIR" 2>/dev/null || true
    local cooldown_file="${ALERT_COOLDOWN_DIR}/${cooldown_key}"
    if [[ -f "$cooldown_file" ]]; then
        local last_alert
        last_alert="$(cat "$cooldown_file" 2>/dev/null || echo 0)"
        local now
        now="$(date +%s)"
        if (( now - last_alert < 3600 )); then
            return 0  # Still in cooldown window
        fi
    fi
    date +%s > "$cooldown_file" 2>/dev/null || true

    curl -s -X POST \
        "https://api.telegram.org/bot${TELEGRAM_TOKEN}/sendMessage" \
        -d "chat_id=${TELEGRAM_CHAT_ID}" \
        --data-urlencode "text=ðŸš¨ wsl-audit CRIT
${message}
Host: $(hostname) | Distro: ${WSL_DISTRO_NAME:-unknown}" \
        --max-time 5 \
        -o /dev/null 2>/dev/null || true
}

crit() {
    echo -e "${RED}${BOLD}[CRIT]${RESET} $*"
    CRIT_COUNT=$((CRIT_COUNT + 1))
    _emit_event "crit" "$CURRENT_SECTION" "$*"
    _send_telegram_alert "$*"
}

warn() {
    echo -e "${YELLOW}[WARN]${RESET} $*"
    WARN_COUNT=$((WARN_COUNT + 1))
    _emit_event "warn" "$CURRENT_SECTION" "$*"
}

ok()   { echo -e "${GREEN}[ OK ]${RESET} $*"; }
info() { echo -e "${CYAN}[INFO]${RESET} $*"; }
dim()  { echo -e "${DIM}$*${RESET}"; }

section() {
    CURRENT_SECTION="$*"
    echo ""
    echo -e "${BOLD}${CYAN}â”â”â” $* â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${RESET}"
}

header() {
    echo ""
    echo -e "${BOLD}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${RESET}"
    echo -e "${BOLD}â•‘  wsl-audit â€” Platform Health Monitor                 â•‘${RESET}"
    printf   "${BOLD}â•‘  %-52s â•‘${RESET}\n" "$(date '+%Y-%m-%d %H:%M:%S')"
    echo -e "${BOLD}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}"
}

summary() {
    echo ""
    echo -e "${BOLD}â”â”â” Summary â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${RESET}"
    if [[ $CRIT_COUNT -gt 0 ]]; then
        echo -e "  ${RED}${BOLD}$CRIT_COUNT critical issue(s) require immediate attention${RESET}"
    fi
    if [[ $WARN_COUNT -gt 0 ]]; then
        echo -e "  ${YELLOW}$WARN_COUNT warning(s) should be reviewed${RESET}"
    fi
    if [[ $CRIT_COUNT -eq 0 && $WARN_COUNT -eq 0 ]]; then
        echo -e "  ${GREEN}${BOLD}All checks passed â€” platform looks healthy${RESET}"
    fi
    if [[ -f "$EVENT_LOG_FILE" ]]; then
        dim "  Event log: $EVENT_LOG_FILE"
    fi
    echo ""

    # Emit structured run summary event
    local ts
    ts="$(date -u '+%Y-%m-%dT%H:%M:%SZ')"
    mkdir -p "$EVENT_LOG_DIR" 2>/dev/null || true
    printf '{"ts":"%s","severity":"info","section":"summary","message":"audit_run_complete","crit_count":%d,"warn_count":%d,"host":"%s","distro":"%s"}\n' \
        "$ts" "$CRIT_COUNT" "$WARN_COUNT" \
        "$(hostname 2>/dev/null || echo 'unknown')" \
        "${WSL_DISTRO_NAME:-unknown}" \
        >> "$EVENT_LOG_FILE" 2>/dev/null || true
}

# â”€â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

check_deps() {
    if command -v docker &>/dev/null && docker info &>/dev/null 2>&1; then
        DOCKER_AVAILABLE=true
    fi
    if command -v powershell.exe &>/dev/null; then
        POWERSHELL_AVAILABLE=true
    fi
}

ps_exec() {
    # Run a PowerShell one-liner from WSL, strip UTF-16 null bytes and CR
    powershell.exe -NoProfile -NonInteractive -Command "$1" 2>/dev/null \
        | tr -d '\r\0'
}

find_wslconfig() {
    # Return the first .wslconfig found in any Windows user home
    local f
    for f in /mnt/c/Users/*/.wslconfig; do
        if [[ -f "$f" ]]; then
            echo "$f"
            return 0
        fi
    done
    return 1
}

# â”€â”€â”€ Subcommand: status â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

cmd_status() {
    section "WSL Status"

    local distro="${WSL_DISTRO_NAME:-unknown}"
    local kernel
    kernel=$(uname -r 2>/dev/null || echo "unknown")
    info "Current distro: ${BOLD}$distro${RESET}"
    info "Kernel: $kernel"

    # .wslconfig check
    local wslconfig
    if wslconfig=$(find_wslconfig); then
        ok ".wslconfig found: $wslconfig"

        local mem_cap
        mem_cap=$(grep -iE '^\s*memory\s*=' "$wslconfig" 2>/dev/null | head -1 | tr -d ' ')
        if [[ -n "$mem_cap" ]]; then
            ok ".wslconfig memory cap: ${BOLD}$mem_cap${RESET}"
        else
            crit ".wslconfig exists but no memory= cap â€” WSL can consume all host RAM"
        fi

        local proc_cap
        proc_cap=$(grep -iE '^\s*processors\s*=' "$wslconfig" 2>/dev/null | head -1 | tr -d ' ')
        if [[ -n "$proc_cap" ]]; then
            ok ".wslconfig processors cap: ${BOLD}$proc_cap${RESET}"
        else
            warn ".wslconfig has no processors= cap (optional but recommended)"
        fi

        local swap_cap
        swap_cap=$(grep -iE '^\s*swap\s*=' "$wslconfig" 2>/dev/null | head -1 | tr -d ' ')
        if [[ -n "$swap_cap" ]]; then
            ok ".wslconfig swap cap: ${BOLD}$swap_cap${RESET}"
        fi
    else
        crit "No .wslconfig found in /mnt/c/Users/*/. No memory cap â€” WSL can consume all host RAM"
        info "  Fix: Create C:\\Users\\<you>\\.wslconfig with [wsl2] then memory=8GB"
    fi

    # Memory usage
    section "Memory Usage"
    local mem_total mem_available mem_pct
    mem_total=$(grep MemTotal /proc/meminfo | awk '{print $2}')
    mem_available=$(grep MemAvailable /proc/meminfo | awk '{print $2}')
    mem_pct=$(( (mem_total - mem_available) * 100 / mem_total ))
    local mem_total_gb=$(( mem_total / 1024 / 1024 ))
    local mem_used_gb=$(( (mem_total - mem_available) / 1024 / 1024 ))

    if [[ $mem_pct -ge 90 ]]; then
        crit "Memory: ${mem_used_gb}GB / ${mem_total_gb}GB (${mem_pct}%) â€” CRITICAL"
    elif [[ $mem_pct -ge 80 ]]; then
        warn "Memory: ${mem_used_gb}GB / ${mem_total_gb}GB (${mem_pct}%) â€” high"
    else
        ok "Memory: ${mem_used_gb}GB / ${mem_total_gb}GB (${mem_pct}%)"
    fi

    # Swap
    local swap_total swap_free
    swap_total=$(grep SwapTotal /proc/meminfo | awk '{print $2}')
    swap_free=$(grep SwapFree /proc/meminfo | awk '{print $2}')
    if [[ $swap_total -gt 0 ]]; then
        local swap_pct=$(( (swap_total - swap_free) * 100 / swap_total ))
        local swap_total_gb=$(( swap_total / 1024 / 1024 ))
        local swap_used_gb=$(( (swap_total - swap_free) / 1024 / 1024 ))
        if [[ $swap_pct -ge 80 ]]; then
            warn "Swap: ${swap_used_gb}GB / ${swap_total_gb}GB (${swap_pct}%) â€” high"
        else
            ok "Swap: ${swap_used_gb}GB / ${swap_total_gb}GB (${swap_pct}%)"
        fi
    else
        info "Swap: not configured"
    fi

    # Disk usage
    section "Disk Usage"
    local disk_used disk_avail disk_pct
    disk_used=$(df -h / | tail -1 | awk '{print $3}')
    disk_avail=$(df -h / | tail -1 | awk '{print $4}')
    disk_pct=$(df / | tail -1 | awk '{print $5}' | tr -d '%')

    if [[ $disk_pct -ge 90 ]]; then
        crit "Root disk: ${disk_used} used, ${disk_avail} free (${disk_pct}%) â€” near full"
    elif [[ $disk_pct -ge 80 ]]; then
        warn "Root disk: ${disk_used} used, ${disk_avail} free (${disk_pct}%) â€” getting full"
    else
        ok "Root disk: ${disk_used} used, ${disk_avail} free (${disk_pct}%)"
    fi

    # Running WSL distros via powershell
    if $POWERSHELL_AVAILABLE; then
        section "WSL Distros (Windows-side)"
        local distro_list
        distro_list=$(ps_exec 'wsl --list --running 2>$null' | grep -v '^\s*$' || true)
        if [[ -n "$distro_list" ]]; then
            info "Running WSL distros:"
            echo "$distro_list" | while IFS= read -r line; do
                dim "  $line"
            done
        else
            info "No additional running distros detected"
        fi
    fi
}

# â”€â”€â”€ Subcommand: docker â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

cmd_docker() {
    section "Docker Container Health"

    if ! $DOCKER_AVAILABLE; then
        info "Docker not available or not running â€” skipping docker checks"
        return
    fi

    local total running stopped restarting
    total=$(docker ps -aq 2>/dev/null | wc -l)
    running=$(docker ps -q --filter status=running 2>/dev/null | wc -l)
    stopped=$(docker ps -q --filter status=exited 2>/dev/null | wc -l)
    restarting=$(docker ps -q --filter status=restarting 2>/dev/null | wc -l)

    info "Containers: ${BOLD}$total total${RESET}, $running running, $stopped exited, $restarting restarting"

    if [[ $restarting -gt 0 ]]; then
        crit "$restarting container(s) actively restarting â€” possible restart storm"
    fi

    if [[ $total -eq 0 ]]; then
        ok "No containers present"
        return
    fi

    # Per-container detail
    section "Container Detail"
    local fmt='{{.Names}}\t{{.Status}}\t{{.RestartCount}}\t{{.HostConfig.RestartPolicy.Name}}'
    local name status restart_count policy

    while IFS=$'\t' read -r name status restart_count policy; do
        if [[ "$restart_count" =~ ^[0-9]+$ ]] && [[ $restart_count -ge 10 ]]; then
            crit "Container ${BOLD}$name${RESET}: restartCount=$restart_count â€” STORM RISK"
        elif [[ "$restart_count" =~ ^[0-9]+$ ]] && [[ $restart_count -ge 3 ]]; then
            warn "Container ${BOLD}$name${RESET}: restartCount=$restart_count, policy=$policy, status=$status"
        elif [[ "$policy" == "always" ]]; then
            warn "Container ${BOLD}$name${RESET}: restart=always (no circuit breaker), status=$status, restarts=$restart_count"
        elif [[ "$policy" == "unless-stopped" ]]; then
            warn "Container ${BOLD}$name${RESET}: restart=unless-stopped (aggressive), status=$status, restarts=$restart_count"
        elif echo "$status" | grep -qi "exited" && ! echo "$status" | grep -qi "exited (0)"; then
            warn "Container ${BOLD}$name${RESET}: $status, restarts=$restart_count"
        else
            ok "Container ${BOLD}$name${RESET}: $status, policy=$policy, restarts=$restart_count"
        fi
    done < <(docker ps -a --format "$fmt" 2>/dev/null)

    # Docker system resource usage
    section "Docker Resource Usage"
    docker system df 2>/dev/null | while IFS= read -r line; do
        dim "  $line"
    done || true
}

# â”€â”€â”€ Subcommand: processes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

cmd_processes() {
    section "WSL/Docker Process Audit"

    if ! $POWERSHELL_AVAILABLE; then
        warn "powershell.exe not available â€” skipping Windows-side process audit"
        info "  (This check only works when run from inside WSL)"
    else
        section "Top WSL/Docker Processes (Windows-side)"
        local wsl_procs
        wsl_procs=$(ps_exec \
            'Get-Process | Where-Object { $_.ProcessName -match "wsl|docker|vmmem" } | Sort-Object CPU -Descending | Select-Object -First 15 | Format-Table ProcessName, Id, @{N="CPU(s)";E={[math]::Round($_.CPU,1)}}, @{N="RAM(MB)";E={[math]::Round($_.WorkingSet/1MB,0)}} -AutoSize | Out-String' \
            || true)
        if [[ -n "$wsl_procs" ]]; then
            echo "$wsl_procs" | while IFS= read -r line; do
                dim "  $line"
            done
        else
            info "No WSL/Docker processes found on Windows side"
        fi

        section "vmmem Memory Usage"
        local vmmem_info
        vmmem_info=$(ps_exec \
            '$v = Get-Process vmmem -ErrorAction SilentlyContinue; if ($v) { $gb = [math]::Round($v.WorkingSet/1GB,2); $mb = [math]::Round($v.WorkingSet/1MB,0); Write-Output "vmmem PID=$($v.Id) WorkingSet=${gb}GB (${mb}MB)" } else { Write-Output "vmmem not running" }' \
            || echo "vmmem check failed")

        if echo "$vmmem_info" | grep -q "not running"; then
            info "$vmmem_info"
        else
            local vmmem_gb
            vmmem_gb=$(echo "$vmmem_info" | grep -oE '[0-9]+\.[0-9]+GB' | head -1 | tr -d 'GB' || echo "0")
            local vmmem_int=${vmmem_gb%.*}
            if [[ "${vmmem_int:-0}" -ge 12 ]]; then
                crit "$vmmem_info â€” very large vmmem, check for runaway containers"
            elif [[ "${vmmem_int:-0}" -ge 8 ]]; then
                warn "$vmmem_info â€” large vmmem"
            else
                ok "$vmmem_info"
            fi
        fi
    fi

    # WSL-side process summary
    section "WSL-side Process Summary"
    local total_procs user_procs
    total_procs=$(ps -e --no-headers 2>/dev/null | wc -l)
    user_procs=$(ps -u "$(id -u)" --no-headers 2>/dev/null | wc -l)
    info "Total processes: $total_procs  (${user_procs} owned by current user)"

    # Flag unusually high process counts (runaway process spawning)
    if [[ $total_procs -ge 500 ]]; then
        warn "Process count ${total_procs} is high â€” possible runaway process spawning"
        info "  Top process spawners:"
        ps -eo comm --no-headers 2>/dev/null | sort | uniq -c | sort -rn | head -5 \
            | while IFS= read -r line; do dim "    $line"; done
    elif [[ $total_procs -ge 300 ]]; then
        warn "Process count ${total_procs} is elevated"
    else
        ok "Process count: $total_procs"
    fi
}

# â”€â”€â”€ Subcommand: compose â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

cmd_compose() {
    local target="${1:-}"

    section "Docker Compose Linter"

    # Find compose files to lint
    local compose_files=()
    if [[ -n "$target" ]] && [[ -d "$target" ]]; then
        while IFS= read -r f; do
            compose_files+=("$f")
        done < <(find "$target" -maxdepth 3 \
            \( -name "docker-compose*.yml" -o -name "docker-compose*.yaml" \
               -o -name "compose.yml" -o -name "compose.yaml" \) \
            2>/dev/null | sort)
    elif [[ -n "$target" ]] && [[ -f "$target" ]]; then
        compose_files=("$target")
    else
        # Search common locations
        while IFS= read -r f; do
            compose_files+=("$f")
        done < <(find "$HOME" /opt 2>/dev/null -maxdepth 4 \
            \( -name "docker-compose*.yml" -o -name "docker-compose*.yaml" \
               -o -name "compose.yml" -o -name "compose.yaml" \) \
            2>/dev/null | sort)
    fi

    if [[ ${#compose_files[@]} -eq 0 ]]; then
        info "No compose files found (pass a path: wsl-audit compose /path/to/dir)"
        return
    fi

    info "Checking ${#compose_files[@]} compose file(s)..."

    local cf
    for cf in "${compose_files[@]}"; do
        echo ""
        info "File: ${BOLD}$cf${RESET}"
        local file_issues=0

        # restart: always â€” no circuit breaker
        if grep -qE '^\s+restart:\s+always' "$cf" 2>/dev/null; then
            warn "  restart: always (no circuit breaker, no backoff)"
            warn "  Fix: Use 'restart: on-failure:5' or add deploy.restart_policy.max_attempts"
            file_issues=$((file_issues + 1))
        fi

        # restart: unless-stopped
        if grep -qE '^\s+restart:\s+unless-stopped' "$cf" 2>/dev/null; then
            warn "  restart: unless-stopped (aggressive â€” persists across Docker restarts)"
            file_issues=$((file_issues + 1))
        fi

        # privileged containers
        if grep -qE '^\s+privileged:\s+true' "$cf" 2>/dev/null; then
            warn "  privileged: true â€” container has full host access"
            file_issues=$((file_issues + 1))
        fi

        # host network mode
        if grep -qE 'network_mode:\s*host' "$cf" 2>/dev/null; then
            warn "  network_mode: host â€” container shares host network stack"
            file_issues=$((file_issues + 1))
        fi

        # Missing memory limits
        if ! grep -qE '(mem_limit|memory:)' "$cf" 2>/dev/null; then
            warn "  No memory limits configured (containers can consume all WSL RAM)"
            file_issues=$((file_issues + 1))
        fi

        # Sensitive volume mounts â€” using double quotes to avoid quoting issues
        local sensitive_mounts
        sensitive_mounts=$(grep -oE "[\"']?/etc:[^\"' ]*|[\"']?/root:[^\"' ]*|[\"']?/proc:[^\"' ]*|[\"']?/sys:[^\"' ]*" "$cf" 2>/dev/null | head -5 || true)
        if [[ -n "$sensitive_mounts" ]]; then
            warn "  Sensitive volume mounts found:"
            echo "$sensitive_mounts" | while IFS= read -r m; do
                dim "    $m"
            done
            file_issues=$((file_issues + 1))
        fi

        # Unresolved environment variable references
        local env_file
        env_file="$(dirname "$cf")/.env"
        local unset_count=0
        while IFS= read -r varname; do
            if [[ -n "$varname" ]]; then
                if [[ -z "${!varname:-}" ]]; then
                    if [[ ! -f "$env_file" ]] || ! grep -q "^${varname}=" "$env_file" 2>/dev/null; then
                        unset_count=$((unset_count + 1))
                    fi
                fi
            fi
        done < <(grep -oE '\$\{?[A-Z_][A-Z0-9_]*\}?' "$cf" 2>/dev/null \
                 | grep -oE '[A-Z_][A-Z0-9_]+' | sort -u | head -20)

        if [[ $unset_count -gt 0 ]]; then
            warn "  $unset_count environment variable(s) may not be set (check .env file)"
            file_issues=$((file_issues + 1))
        fi

        if [[ $file_issues -eq 0 ]]; then
            ok "  No issues found"
        fi
    done
}

# â”€â”€â”€ Subcommand: risks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

cmd_risks() {
    section "Proactive Risk Detection"

    # 1. Docker Desktop Windows auto-start
    if $POWERSHELL_AVAILABLE; then
        local dd_autostart
        dd_autostart=$(ps_exec \
            '$r = "HKCU:\Software\Microsoft\Windows\CurrentVersion\Run"; $v = Get-ItemProperty $r -Name "Docker Desktop" -ErrorAction SilentlyContinue; if ($v) { Write-Output "enabled" } else { Write-Output "not-set" }' \
            || echo "check-failed")
        if [[ "$dd_autostart" == "enabled" ]]; then
            warn "Docker Desktop in Windows startup â€” launches on every boot"
            warn "  Early-boot restart storms risk if containers were left running"
        elif [[ "$dd_autostart" == "not-set" ]]; then
            ok "Docker Desktop: not in Windows startup"
        else
            info "Docker Desktop auto-start: could not check (PowerShell required)"
        fi
    fi

    # 2. .wslconfig memory cap
    if find_wslconfig >/dev/null 2>&1; then
        local wslconfig
        wslconfig=$(find_wslconfig)
        if grep -qiE '^\s*memory\s*=' "$wslconfig" 2>/dev/null; then
            local cap
            cap=$(grep -iE '^\s*memory\s*=' "$wslconfig" | head -1 | tr -d ' ')
            ok ".wslconfig memory cap: $cap"
        else
            crit ".wslconfig exists but no memory= cap â€” restart storm can consume all host RAM"
        fi
    else
        crit "No .wslconfig memory cap â€” restart storm can consume all host RAM"
        info "  Fix: Add [wsl2] then memory=8GB to C:\\Users\\<you>\\.wslconfig"
    fi

    # 3. Containers currently restarting
    if $DOCKER_AVAILABLE; then
        local restarting_names
        restarting_names=$(docker ps --filter status=restarting --format '{{.Names}}' 2>/dev/null | tr '\n' ' ')
        if [[ -n "$restarting_names" ]]; then
            crit "Containers currently in restart loop: $restarting_names"
        else
            ok "No containers currently in restart state"
        fi

        # High restart count containers
        local high_restart_info=""
        while IFS=$'\t' read -r cname ccount; do
            if [[ "$ccount" =~ ^[0-9]+$ ]] && [[ $ccount -ge 5 ]]; then
                high_restart_info="$high_restart_info $cname(${ccount}x)"
            fi
        done < <(docker ps -a --format '{{.Names}}\t{{.RestartCount}}' 2>/dev/null)

        if [[ -n "$high_restart_info" ]]; then
            warn "Containers with high restart counts:$high_restart_info"
        else
            ok "No containers with high restart counts"
        fi

        # Stale exited containers
        local stale_count
        stale_count=$(docker ps -q --filter status=exited 2>/dev/null | wc -l)
        if [[ $stale_count -ge 20 ]]; then
            warn "$stale_count exited containers accumulated â€” run: docker container prune"
        elif [[ $stale_count -ge 5 ]]; then
            info "$stale_count exited containers (run: docker container prune when convenient)"
        else
            ok "Exited containers: $stale_count (clean)"
        fi

        # Dangling images
        local dangling
        dangling=$(docker images -f dangling=true -q 2>/dev/null | wc -l)
        if [[ $dangling -ge 10 ]]; then
            warn "$dangling dangling images â€” run: docker image prune"
        else
            ok "Dangling images: $dangling"
        fi

        # Docker root disk usage
        local docker_root
        docker_root=$(docker info --format '{{.DockerRootDir}}' 2>/dev/null || echo "")
        if [[ -n "$docker_root" ]] && [[ -d "$docker_root" ]]; then
            local dp
            dp=$(df "$docker_root" 2>/dev/null | tail -1 | awk '{print $5}' | tr -d '%')
            if [[ -n "$dp" ]]; then
                if [[ $dp -ge 90 ]]; then
                    crit "Docker root disk ($docker_root): ${dp}% full"
                elif [[ $dp -ge 80 ]]; then
                    warn "Docker root disk ($docker_root): ${dp}% full"
                else
                    ok "Docker root disk ($docker_root): ${dp}% used"
                fi
            fi
        fi
    else
        info "Docker not available â€” skipping container risk checks"
    fi

    # 4. Current WSL memory pressure
    local mem_total mem_available mem_pct
    mem_total=$(grep MemTotal /proc/meminfo | awk '{print $2}')
    mem_available=$(grep MemAvailable /proc/meminfo | awk '{print $2}')
    mem_pct=$(( (mem_total - mem_available) * 100 / mem_total ))
    if [[ $mem_pct -ge 90 ]]; then
        crit "Current WSL memory pressure: ${mem_pct}% â€” immediate risk"
    elif [[ $mem_pct -ge 80 ]]; then
        warn "Current WSL memory pressure: ${mem_pct}%"
    else
        ok "Current WSL memory pressure: ${mem_pct}%"
    fi
}

# â”€â”€â”€ Subcommand: all â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

cmd_all() {
    header
    check_deps

    cmd_status
    cmd_docker
    cmd_processes
    cmd_compose "${1:-}"
    cmd_risks

    summary
}

# â”€â”€â”€ Subcommand: watch â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

cmd_watch() {
    local interval="${1:-30}"
    if ! [[ "$interval" =~ ^[0-9]+$ ]]; then
        echo "Usage: wsl-audit watch [seconds]" >&2
        exit 1
    fi
    echo "Watching â€” refreshing every ${interval}s (Ctrl+C to stop)"
    while true; do
        CRIT_COUNT=0
        WARN_COUNT=0
        if [[ -t 1 ]]; then
            clear
        fi
        cmd_all
        echo ""
        echo -e "${DIM}Next refresh in ${interval}s â€” Ctrl+C to stop${RESET}"
        sleep "$interval"
    done
}

# â”€â”€â”€ Subcommand: events â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

cmd_events() {
    local n="${1:-20}"
    local log_dir="$EVENT_LOG_DIR"

    section "Event Log â€” Last ${n} Entries"

    if [[ ! -d "$log_dir" ]]; then
        info "No event log directory found: $log_dir"
        info "Run 'wsl-audit all' first to generate events"
        return
    fi

    # Find most recent log files
    local log_files=()
    while IFS= read -r f; do
        log_files+=("$f")
    done < <(ls -t "${log_dir}/"*.jsonl 2>/dev/null | head -7)

    if [[ ${#log_files[@]} -eq 0 ]]; then
        info "No event log files found in $log_dir"
        return
    fi

    info "Log directory: $log_dir"
    info "Files: ${log_files[*]}"

    # Show recent entries from most recent file, crits/warns highlighted
    local entry_count=0
    while IFS= read -r line; do
        [[ -z "$line" ]] && continue
        entry_count=$((entry_count + 1))
        if echo "$line" | grep -q '"severity":"crit"'; then
            echo -e "${RED}${BOLD}$line${RESET}"
        elif echo "$line" | grep -q '"severity":"warn"'; then
            echo -e "${YELLOW}$line${RESET}"
        else
            dim "$line"
        fi
    done < <(tail -n "$n" "${log_files[0]}" 2>/dev/null)

    if [[ $entry_count -eq 0 ]]; then
        info "No entries in most recent log file: ${log_files[0]}"
    fi

    echo ""
    info "All log files:"
    for f in "${log_files[@]}"; do
        local count
        count=$(wc -l < "$f" 2>/dev/null || echo "?")
        dim "  $f  ($count entries)"
    done
}

# â”€â”€â”€ Subcommand: help â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

cmd_help() {
    cat <<'HELPEOF'
wsl-audit â€” WSL/Docker platform health monitoring tool

USAGE:
    wsl-audit <command> [args]

COMMANDS:
    status               WSL overview: distros, memory, .wslconfig caps
    docker               Container health: states, restart counts, policies
    processes            Windows-side process audit (requires powershell.exe)
    compose [path]       Docker Compose linter: risky patterns, missing limits
                         Optional: path to directory or compose file to lint
    risks                Proactive risk detection (auto-start, missing caps, storms)
    all [path]           Run all checks (pass compose path for linter)
    watch [N]            Re-run all checks every N seconds (default: 30)
    events [N]           Show last N structured event log entries (default: 20)
                         Log: ~/.local/share/wsl-audit/events/YYYY-MM-DD.jsonl

SEVERITY LEVELS:
    [CRIT]  Requires immediate attention â€” platform safety risk
    [WARN]  Should be reviewed â€” potential issue
    [ OK ]  Check passed
    [INFO]  Informational

CRITICAL PATTERNS DETECTED:
    - Docker containers with restart: always (no circuit breaker)
    - RestartCount >= 3 (restart loop risk), >= 10 (storm in progress)
    - Missing .wslconfig memory cap
    - Memory usage >= 80% or disk usage >= 80%
    - Docker Desktop in Windows auto-start
    - Currently restarting containers

TELEGRAM ALERTING (Phase 2):
    Set TELEGRAM_TOKEN and TELEGRAM_CHAT_ID in:
    ~/.local/share/wsl-audit/alert.env
    CRIT events trigger Telegram alerts with 1-hour cooldown per message.

EXAMPLES:
    wsl-audit all                          Run full check
    wsl-audit compose ~/LibreChat/         Lint LibreChat compose files
    wsl-audit watch 60                     Monitor, refresh every 60s
    wsl-audit docker                       Quick container health check
    wsl-audit risks                        Proactive risk summary only
    wsl-audit events 50                    Show last 50 log entries

GOVERNANCE (INTenX WSL instances):
    - .wslconfig with memory= cap is REQUIRED before running AI services
    - No restart: always without deploy.restart_policy.max_attempts limit
    - Run 'wsl-audit compose' before starting any new Docker service

HELPEOF
}

# â”€â”€â”€ Main dispatch â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

main() {
    local cmd="${1:-help}"
    shift || true

    if [[ "$cmd" != "all" && "$cmd" != "watch" ]]; then
        check_deps
    fi

    case "$cmd" in
        status)    cmd_status ;;
        docker)    cmd_docker ;;
        processes) cmd_processes ;;
        compose)   cmd_compose "${1:-}" ;;
        risks)     cmd_risks ;;
        all)       cmd_all "${1:-}" ;;
        watch)     cmd_watch "${1:-30}" ;;
        events)    cmd_events "${1:-20}" ;;
        help|--help|-h) cmd_help ;;
        *)
            echo "Unknown command: $cmd" >&2
            echo "Run 'wsl-audit help' for usage" >&2
            exit 1
            ;;
    esac

    if [[ "$cmd" =~ ^(status|docker|processes|compose|risks)$ ]]; then
        summary
    fi
}

main "$@"
